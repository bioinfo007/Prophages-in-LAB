#!/usr/bin/env python3
"""
compute_prophage_overlap.py

Purpose
-------
This script compares prophage predictions generated by PhiSpy and Phigaro
using genomic coordinate overlap. It identifies:
1) Prophages predicted by both tools (overlapping regions)
2) Prophages predicted only by PhiSpy
3) Prophages predicted only by Phigaro

Overlap is defined as an absolute nucleotide overlap of at least
a user-specified minimum length (e.g. 1000 bp).

Input requirements
------------------
1) PhiSpy output file (TSV) containing the following columns:
   - Prophage number
   - contig_id
   - prophage_start
   - prophage_stop

2) Phigaro output file (TSV) containing the following columns:
   - scaffold
   - id
   - begin
   - end

Usage
-----
python compare_prophages.py phispy.tsv phigaro.tsv output_prefix min_overlap

Example
-------
python compare_prophages.py phispy.tsv phigaro.tsv result 1000

Output files
------------
1) <output_prefix>_overlap.tsv
   - Prophages predicted by both PhiSpy and Phigaro

2) <output_prefix>_phispy_only.tsv
   - Prophages predicted only by PhiSpy

3) <output_prefix>_phigaro_only.tsv
   - Prophages predicted only by Phigaro

Notes
-----
- Scaffold/contig IDs are treated as genome identifiers.
- Only the first overlapping Phigaro region per PhiSpy prophage
  is retained.
- Overlap is based on absolute nucleotide length, not percentage.
Author: Aqib Javaid
"""

import sys

def read_phigaro(filename):
    prophages = []
    with open(filename) as f:
        header = f.readline().strip().split('\t')
        idx_scaffold = header.index('scaffold')
        idx_id = header.index('id')
        idx_begin = header.index('begin')
        idx_end = header.index('end')

        for line in f:
            parts = line.strip().split('\t')
            prophages.append({
                'id': parts[idx_id],
                'genome': parts[idx_scaffold],   # use scaffold as genome+contig id
                'contig': parts[idx_scaffold],
                'start': int(parts[idx_begin]),
                'end': int(parts[idx_end])
            })
    return prophages

def read_phispy(filename):
    prophages = []
    with open(filename) as f:
        header = f.readline().strip().split('\t')
        idx_id = header.index('Prophage number')
        idx_contig = header.index('contig_id')
        idx_start = header.index('prophage_start')
        idx_end = header.index('prophage_stop')

        for line in f:
            parts = line.strip().split('\t')
            prophages.append({
                'id': parts[idx_id],
                'genome': parts[idx_contig],    # contig as genome+contig id
                'contig': parts[idx_contig],
                'start': int(parts[idx_start]),
                'end': int(parts[idx_end])
            })
    return prophages

def overlap_length(a_start, a_end, b_start, b_end):
    return max(0, min(a_end, b_end) - max(a_start, b_start) + 1)

def find_overlaps(phispy, phigaro, min_overlap=1000):
    overlaps = []
    phispy_only = []
    phigaro_only = phigaro.copy()

    phigaro_index = {}
    for p in phigaro:
        key = (p['genome'], p['contig'])
        phigaro_index.setdefault(key, []).append(p)

    matched_phigaro_ids = set()

    for p_spy in phispy:
        key = (p_spy['genome'], p_spy['contig'])
        found_match = False
        if key in phigaro_index:
            for p_garo in phigaro_index[key]:
                ov = overlap_length(p_spy['start'], p_spy['end'], p_garo['start'], p_garo['end'])
                if ov >= min_overlap:
                    overlaps.append( (p_spy, p_garo) )
                    matched_phigaro_ids.add(p_garo['id'])
                    found_match = True
                    break
        if not found_match:
            phispy_only.append(p_spy)

    phigaro_only = [p for p in phigaro if p['id'] not in matched_phigaro_ids]

    return overlaps, phispy_only, phigaro_only

def write_output(filename, prophages, header=None):
    with open(filename, 'w') as f:
        if header:
            f.write(header + '\n')
        for p in prophages:
            f.write(f"{p['id']}\t{p['genome']}\t{p['contig']}\t{p['start']}\t{p['end']}\n")

def write_overlaps(filename, overlaps):
    with open(filename, 'w') as f:
        f.write("#phispy_id\tphispy_genome\tphispy_contig\tphispy_start\tphispy_end\tphigaro_id\tphigaro_genome\tphigaro_contig\tphigaro_start\tphigaro_end\n")
        for p_spy, p_garo in overlaps:
            f.write(f"{p_spy['id']}\t{p_spy['genome']}\t{p_spy['contig']}\t{p_spy['start']}\t{p_spy['end']}\t{p_garo['id']}\t{p_garo['genome']}\t{p_garo['contig']}\t{p_garo['start']}\t{p_garo['end']}\n")

if __name__ == "__main__":
    if len(sys.argv) != 5:
        print("Usage: python compare_prophages.py phispy.tsv phigaro.tsv output_prefix min_overlap")
        print("Example: python compare_prophages.py phispy.tsv phigaro.tsv result 1000")
        sys.exit(1)

    phispy_file = sys.argv[1]
    phigaro_file = sys.argv[2]
    out_prefix = sys.argv[3]
    min_ov = int(sys.argv[4])

    phispy_prophages = read_phispy(phispy_file)
    phigaro_prophages = read_phigaro(phigaro_file)

    overlaps, phispy_only, phigaro_only = find_overlaps(phispy_prophages, phigaro_prophages, min_ov)

    write_overlaps(f"{out_prefix}_overlap.tsv", overlaps)
    write_output(f"{out_prefix}_phispy_only.tsv", phispy_only, header="prophage_id\tgenome\tcontig\tstart\tend")
    write_output(f"{out_prefix}_phigaro_only.tsv", phigaro_only, header="prophage_id\tgenome\tcontig\tstart\tend")

    print(f"Overlapping prophages: {len(overlaps)}")
    print(f"PhiSpy-only prophages: {len(phispy_only)}")
    print(f"Phigaro-only prophages: {len(phigaro_only)}")
